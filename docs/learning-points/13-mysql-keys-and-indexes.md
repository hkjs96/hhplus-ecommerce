# MySQL(InnoDB) 키/인덱스 핵심 정리 (자연키 vs 대체키, PK vs Secondary Index)

> 목적: 4~5주차(DB) 체크리스트의 “자연키/대체키”와 “MySQL PK/인덱스/클러스터링 인덱스”를 한 장으로 정리한다.

---

## 1) 자연키(Natural Key) vs 대체키(Surrogate Key)

### 정의
- **자연키**: 업무적으로 의미가 있는 값이면서 유일성까지 만족하는 키  
  - 예: `email`, `phone_number`, `coupon_code`, `order_number`
- **대체키**: 의미는 없지만 식별을 위해 추가로 만든 키(주로 숫자 PK)  
  - 예: `user_id BIGINT`, `order_id BIGINT`

### 언제 자연키가 위험해지나?
- **변할 수 있는 값**(email 변경, 전화번호 변경 등)을 키로 쓰면, 연쇄적으로 FK/인덱스/조인에 영향이 커진다.
- 자연키가 길거나 문자열이면, 인덱스 크기/비교 비용이 커지고 캐시 효율이 떨어질 수 있다.

### 실무적으로 가장 흔한 선택(권장 패턴)
- **대체키를 PK로 두고**, 자연키는 **Unique Index**로 강제한다.
  - 예: `users(id BIGINT PK, email VARCHAR UNIQUE, ...)`
- 장점
  - 조인/PK 기반 조회가 빠르고 안정적이다.
  - 자연키 변경 요구사항에 대응하기 쉽다(Unique key는 업데이트로 해결 가능).
  - 외부 노출 식별자(예: 주문번호)는 별도 컬럼/정책으로 운영 가능하다.

---

## 2) MySQL(InnoDB)에서 “클러스터링 인덱스(Clustered Index)”란?

InnoDB에서 테이블 데이터는 **PK(Primary Key) 기준으로 물리적으로 정렬**되어 저장됩니다.  
이 “PK 기반 데이터 저장 구조”를 흔히 **클러스터링 인덱스**라고 부릅니다.

핵심 정리
- **PK = 데이터의 실제 저장 순서(= 테이블 그 자체에 가까움)**
- PK로 조회하면 “인덱스 → 데이터”가 아니라 **곧바로 데이터 페이지**로 접근하는 것에 가깝다.

> 주의: DBMS마다 clustered index의 의미/구현은 다를 수 있고, InnoDB에서는 “PK가 곧 clustered index”라는 관점으로 이해하면 충분합니다.

---

## 3) MySQL PK 인덱스 vs Secondary Index(보조 인덱스)

### PK 인덱스
- 리프(leaf) 페이지에 **행 전체(row)**가 저장된다(= 데이터).
- PK 조회는 빠르고 일관된 접근 경로가 된다.

### Secondary Index(보조 인덱스)
- 리프 페이지에는 **(secondary key, PK 값)**이 저장된다.
- 그래서 보조 인덱스로 조건을 걸어 행을 찾을 때:
  1) 보조 인덱스에서 PK를 찾고
  2) 그 PK로 다시 PK(클러스터드)에서 row를 찾는다
  - 이 2단계 접근을 흔히 **“back to table(테이블로 돌아감)”**이라고 부릅니다.

### 커버링 인덱스(Covering Index)
- SELECT에 필요한 컬럼이 보조 인덱스에 **모두 포함**되면, 2) 단계가 생략될 수 있습니다.
  - “테이블로 돌아갈 필요가 없다” → 조회가 매우 빨라질 수 있음

---

## 4) 인덱스 설계의 기본 규칙(실전)

### 1) 복합 인덱스의 “왼쪽 접두(Leftmost Prefix)”
복합 인덱스가 `(a, b, c)`면, 조건이 아래 형태일 때 유리합니다.
- `a = ?`
- `a = ? AND b = ?`
- `a = ? AND b = ? AND c = ?`
- `a = ? AND b BETWEEN ? AND ?` (범위 조건 이후 컬럼은 활용이 제한될 수 있음)

### 2) 카디널리티(선택도)가 중요한 컬럼을 앞에
가능하면 “값이 다양해서 잘 걸러지는 컬럼”을 앞에 두는 것이 일반적으로 유리합니다.  
다만 “정렬/그룹/범위 조건”까지 포함하면 최적 순서는 케이스마다 달라질 수 있어 `EXPLAIN`으로 확인합니다.

### 3) Unique Index는 ‘정합성’도 같이 책임진다
자연키(쿠폰 코드, 사용자 이메일 등)는 PK로 쓰지 않더라도 Unique Index로 강제해서 데이터 품질을 올립니다.

---

## 5) 락과 인덱스의 관계(개념만 최소)

InnoDB는 보통 “원하는 행을 찾기 위해 사용하는 **인덱스 범위**”를 기준으로 락을 잡습니다.  
그래서 **적절한 인덱스가 없으면**:
- 더 넓은 범위를 스캔/락 잡게 되어 동시성이 떨어질 수 있고
- 최악의 경우 의도치 않은 경합/대기가 커질 수 있습니다.

이 레포에서도 동시성/락 이슈는 단순히 “락을 쓰자”가 아니라,
**어떤 조건으로 어떤 인덱스를 타고 들어가 락 범위를 좁히는가**가 핵심입니다.

---

## 6) 요약(체크리스트 답변용)

- 자연키 vs 대체키: **대체키(PK) + 자연키(Unique)** 조합이 가장 일반적이고 안전하다.
- InnoDB PK(클러스터드): **PK 기준으로 row가 저장**된다.
- Secondary index: 리프에 **PK를 들고 있고**, 필요 시 PK로 다시 row를 찾는다(커버링이면 생략 가능).
- 인덱스는 성능뿐 아니라 **락 범위/동시성**에도 영향을 준다.

