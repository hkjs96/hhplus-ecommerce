# JVM GC 알고리즘: 무엇이 다르고, 운영에서 무엇을 봐야 하나?

> 목적: “GC 알고리즘을 나열”이 아니라, 성능/운영 관점에서 GC를 설명하고 관측 지표로 연결한다.

---

## 1) GC는 왜 필요한가?

JVM은 객체를 힙에 할당하고, 더 이상 참조되지 않는 객체를 회수합니다.  
이 회수 작업(GC)이 과도해지면 **Stop-The-World(STW) pause**가 늘어나고, 지연시간(p95/p99)에 직접 영향을 줍니다.

---

## 2) 기본 전제: 세대별(Generational) 힙(감각)

대부분의 객체는 “금방 죽는다”는 가정이 성립하는 경우가 많아,
- Young(새 객체)
- Old(오래 사는 객체)
로 나눠 관리합니다.

그래서 흔히
- Young GC(빈번하지만 짧게)
- Old/Full GC(덜 빈번하지만 길게)
의 형태로 체감됩니다.

---

## 3) 대표 GC 알고리즘(이름만 외우지 말고 ‘특성’으로)

### Serial GC
- 단일 스레드로 GC 수행
- 작은 힙/단순 환경에만 적합

### Parallel GC
- GC를 병렬로 수행(throughput 지향)
- 배치/처리량 중심 워크로드에 적합한 경우가 많음

### G1 GC (Garbage-First)
- 힙을 region 단위로 쪼개 관리
- “pause time 목표”를 두고 수집 범위를 조절하려는 성격
- 대다수 서버 사이드 JVM에서 기본 선택지로 자주 쓰임

### ZGC / Shenandoah (Low-latency GC)
- 목표는 “아주 긴 STW pause를 줄이는 것”
- 시스템/버전/옵션 제약이 있고 운영 난이도가 올라갈 수 있음
- 초저지연이 중요한 환경에서 고려

> 핵심: “무조건 최신 GC가 정답”이 아니라, 서비스 목표(지연/처리량)와 운영 난이도를 같이 봅니다.

---

## 4) 운영에서 GC를 어떻게 해석하나? (지표 연결)

GC 자체 지표만 보지 말고, 아래 순서가 실무적으로 안전합니다.

1. **증상**: API 지연(p95/p99), 5xx/timeout 증가
2. **원인 후보**: GC pause 증가, heap 사용률 상승, allocation rate 급증
3. **연결**: “GC pause가 증가한 시점”과 “지연이 튄 시점”이 겹치는가?

이 레포의 관측 문서:
- `docs/week10/monitoring-metrics.md` (GC/heap/threads 지표 포함)
- `docs/week10/RUNBOOK.md` (GC/메모리 압박 대응 루틴)

---

## 5) 흔한 케이스(현업형)

- **Full GC가 간헐적으로 터짐** → p99 지연이 튀고, 타임아웃이 증가할 수 있음
- **GC pause는 짧지만 너무 자주 발생** → 처리량 저하/CPU 상승으로 이어질 수 있음
- **메모리 누수/캐시 폭주** → heap이 계속 차서 old 영역 압박 → pause 증가

---

## 6) 체크리스트 답변용 요약(3줄)

1. GC는 힙 메모리 회수 작업이고, STW pause가 커지면 API 지연(p95/p99)에 직접 영향을 준다.  
2. 알고리즘은 Serial/Parallel/G1/ZGC처럼 “throughput vs latency” 성격이 다르고, 목표와 운영 난이도로 선택한다.  
3. 운영에서는 GC 지표만 단독으로 보지 말고, 지연/에러 같은 증상과 GC pause/heap 압박 시점을 연결해 해석한다.

