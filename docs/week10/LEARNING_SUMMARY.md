# Week 10 학습 정리 - STEP 19-20 장애 대응 & 성능 테스트

> **작성일**: 2025-12-26  
> **학습 주제**: 부하 테스트 설계(k6), 관측 가능성(RED/Golden Signals), 병목 탐색, (가상) 장애 대응/포스트모템  
> **참고 문서**: `docs/week10/step19-load-test-plan.md`, `docs/week10/step20-incident-report.md`, `docs/week10/monitoring-metrics.md`  
> **참고(외부)**: Google SRE Book/Workbook의 “SLI/SLO, Alerting, Incident Response, Postmortem” 가이드라인

---

## 1) 이번 주 핵심 학습 목표

- 부하 테스트를 “실행”이 아니라 “설계”로 접근하기
  - 무엇을(대상), 어떻게(시나리오/부하 모델), 어떤 기준으로(목표치/임계치) 측정할지 정의
- 관측 가능성을 “지표 나열”이 아니라 “의사결정 도구”로 쓰기
  - 장애 탐지(알림) → 원인 분석(드릴다운) → 복구(완화) → 회고(재발 방지)로 연결
- (가상) 장애 대응 문서를 “기술 이슈 해결”을 넘어 운영 프로세스 관점으로 작성하기
  - 등급/전파 기준(비즈니스) + 타임라인(탐지/대응/복구) + 포스트모템(Do not blame)

---

## 2) SRE 관점으로 정리한 “성능/장애 대응” 프레임

### 2-1) SLI/SLO/SLA 감각 잡기
- **SLI**: 사용자 경험을 대변하는 측정값(예: 요청 성공률, p95 지연시간)
- **SLO**: 목표(예: “/api/orders 성공률 99.9%”, “p95 500ms 이하”)
- **SLA**: 대외 약속(보상/패널티 포함)

실무적으로는 “기술 지표(CPU/GC 등)”보다 “사용자 영향 지표”를 먼저 본다. (SRE의 핵심 원칙 중 하나)

### 2-2) Error Budget과 릴리스/개선의 균형
- SLO를 만족하지 못해 에러 버짓이 소진되면, 기능 개발보다 안정성 개선을 우선
- 이 과제에서는 실제 SLA/SLO가 없으므로, “가상의 SLO”를 문서로 먼저 정의한 뒤 부하 테스트를 수행하는 흐름을 연습했다.

### 2-3) Alert는 “행동 가능한 신호”가 되어야 한다
- 알람은 “원인”이 아니라 “증상(사용자 영향)”에 가깝게 설계하는 것이 일반적으로 유리
- 예: `/api/**` 5xx 비율 상승, 주문/결제 p95 급상승 등 → 확인/대응 Runbook으로 연결

---

## 3) 관측(Observability): Golden Signals/RED 적용

### 3-1) Golden Signals (SRE에서 자주 쓰는 4대 신호)
- **Latency**: p95/p99로 tail latency를 본다
- **Traffic**: RPS/TPS, 엔드포인트별 분포
- **Errors**: 5xx, timeout, (의도된) 4xx와 구분
- **Saturation**: CPU, 메모리, DB 커넥션 풀 포화, 큐 적체 등

### 3-2) RED(요청 중심)로 시작하고, 원인 신호로 드릴다운
- RED로 “어디가 문제인지”(엔드포인트/상황)를 좁힌 뒤,
- JVM/DB Pool/Kafka/Redis 지표로 “왜 문제인지”를 찾는 흐름이 효율적이었다.

이번 주 대시보드는 아래 2가지로 역할을 분리했다.
- **API RED (Endpoint View)**: 엔드포인트별 RPS/에러/지연 + Top N
- **Overview (RED + JVM + DB)**: 리소스/GC/DB pool 등 포화 신호 확인

---

## 4) 부하 테스트(k6): “재현 가능성”이 핵심

### 4-1) 대상/시나리오
- 대상: 인증 없는 `/api/**` 전체(운영/문서 엔드포인트 제외)
- 방식: “전체 API 순환(Baseline) + 핫스팟 증폭(Amplify)”의 확장 가능 구조
- 상태 변화 API(주문/결제/쿠폰/장바구니 write)는 기본 확률을 낮춰, 데이터 누적/충돌로 인한 실패를 완화하고 측정 안정성을 높였다.

### 4-2) 부하 모델
- ramping-vus로 “가벼운 기본 + 점진 증가”를 표현
- 워밍업/측정 구간을 분리해 비교 가능성을 유지하는 것이 중요

### 4-3) 측정 해석에서 주의한 점
- k6 `http_req_failed`는 “4xx까지 포함한 실패율”로 오해하기 쉬움
  - 따라서 “의도된 4xx(정책/재고/중복)”와 “비의도 5xx/timeout”을 분리해서 봐야 한다.
- tail latency(p95/p99)는 평균보다 장애 체감과 더 가깝다.

---

## 5) (가상) 장애 케이스 학습: Kafka advertised/listener 불일치

### 5-1) 현상 요약
- Docker 환경에서 앱 컨테이너가 Kafka로 연결할 때 `localhost:9092`로 재접속을 시도 → 연결 실패/재시도 → 일부 요청에서 지연/타임아웃 발생 가능

### 5-2) 원인(왜 이런 일이 생겼나)
- Kafka는 bootstrap으로 연결 후, broker metadata(광고 주소)를 받는다.
- broker가 “컨테이너 내부 접근 주소”가 아니라 `localhost`만 advertise하면,
  - 컨테이너 내부 클라이언트는 자기 자신(localhost)을 바라보게 되어 장애가 발생한다.

### 5-3) 대응/개선 포인트
- 내부/외부 리스너를 분리하여, 컨테이너 내부는 `kafka:29092`, 호스트는 `localhost:9092`로 접근하도록 구성
- 이 타입의 장애는 “코드”가 아니라 “환경/설정”으로 발생하며, 그래서 회귀 체크리스트(런북)가 특히 중요했다.

---

## 6) 포스트모템(Do not blame) 템플릿을 써 본 포인트

- 타임라인은 “무엇을 언제 어떻게 알았고(탐지), 어떤 결정을 했으며(전파/완화), 무엇으로 복구됐는지(복구)”가 핵심
- 5 Whys는 책임 추궁이 아니라 “시스템/프로세스 결함”을 찾기 위한 도구
- 액션 아이템은 P0/P1로 우선순위가 있어야 실행 가능해진다.

---

## 7) 남은 과제(후속)

- 동시 요청에서 `POST /api/cart/items`가 간헐적으로 `500(COMMON001)`을 반환하는 케이스
  - 목표: 원인 재현(테스트) → 5xx 제거 또는 “정상적인 4xx로 치환”(경합/멱등/검증 실패의 처리)
  - 힌트: `CART_WRITE_PROB=1` + 5 VUs에서 관측

