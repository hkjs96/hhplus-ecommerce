# Week 10 - SLO/SLI/Alerting 설계 가이드 (학습용)

이 문서는 “무엇을 알림으로 울릴지”를 정하기 위한 실무형 가이드입니다. 핵심은 **알림을 많이 만드는 것**이 아니라, **의미 있는 알림만 만들고(행동 가능), 그 알림에 대응할 수 있게(런북) 만드는 것**입니다.

## 1) 용어 정리(최소)
- **SLI (Indicator):** 측정 지표(예: API 성공률, p95 지연시간)
- **SLO (Objective):** 목표(예: “30일 기준 성공률 99.9%”)
- **SLA:** 계약(페널티 포함). 학습 단계에서는 보통 SLO까지만 설계합니다.

## 2) 무엇을 SLI로 잡을까? (이 프로젝트 기준 추천)
### 2.1 사용자 경로 중심 API SLI (추천 1순위)
- **성공률(Availability):** `2xx/3xx 비율`, 또는 `1 - 5xx 비율`
- **지연시간(Latency):** p95, p99
- **에러율(Error Rate):** 5xx, 또는 “비즈니스 실패율”(재고부족/쿠폰만료 등)과 분리

### 2.2 의존성 SLI (운영 난이도에 비례해 추가)
- DB: 커넥션 풀 포화/쿼리 지연/락
- Redis: hit ratio, evictions, 커넥션 에러
- Kafka: broker up, consumer lag(있다면), produce error

### 2.3 리소스 SLI(보조)
- CPU/메모리/디스크. 단, 리소스만으로는 “사용자 영향”을 보장하지 못해 보조로 둡니다.

## 3) SLO 예시(학습용 가이드라인)
숫자는 “정답”이 아니라, 서비스 성격(트래픽/기능/조직)을 반영해 조정합니다.

### 3.1 API 성공률(30일)
- 핵심 API(주문 생성/결제/상품 조회): **99.9%**
- 기타 API: **99.5%**

### 3.2 API 지연시간(30일)
- 조회 API: p95 **< 300ms**, p99 **< 800ms**
- 쓰기 API(주문/결제): p95 **< 700ms**, p99 **< 2s**

### 3.3 배치/비동기 처리(있다면)
- 이벤트 처리 지연(consumer lag 또는 end-to-end 처리시간): “p95 < N초” 형태로 정의

## 4) 알림 설계 원칙(현장에서 진짜 중요한 부분)
### 4.1 알림은 “행동 가능(Actionable)” 해야 한다
- 알림을 받았을 때, “누가 무엇을 하면 되는지”가 떠오르지 않으면 알림이 아닙니다.
- 모든 알림은 런북 링크가 있어야 합니다: `docs/week10/RUNBOOK.md`

### 4.2 증상(Symptom) 알림을 먼저, 원인(Cause) 알림은 나중에
- **증상 알림:** 사용자 영향(5xx, latency) → 가장 중요
- **원인 알림:** CPU/메모리/디스크, DB 커넥션 포화 → 보조

### 4.3 Alert fatigue를 피한다
- 너무 민감한 알림(자주 울리는데 조치할 게 없음)은 제거/조정합니다.
- “경보(페이지)”와 “경고(티켓/슬랙)”를 분리합니다.

### 4.4 멀티 윈도우/멀티 버너(MWB/Multi-burn-rate)
같은 SLO라도 “빠르게 타는(급격한 악화)” 상황은 즉시 대응이 필요합니다.
- 예: 5분 창에서 에러 급증(긴급) + 1시간 창에서 누적 악화(지속 문제)

## 5) Prometheus 알림(예시 아이디어)
현재 레포는 로컬 관측용 Prometheus/Grafana 구성이 있으므로, 아래는 “어떤 알림을 만들 수 있는지”에 대한 예시입니다(실제 메트릭 이름은 프로젝트 설정에 따라 다를 수 있음).

### 5.1 API 에러율(증상)
- 조건 예시(개념):
  - 최근 5분 5xx 비율이 2% 초과(페이지)
  - 최근 30분 5xx 비율이 1% 초과(경고)

### 5.2 API 지연시간(증상)
- 조건 예시(개념):
  - p95가 5분 이상 임계치 초과(페이지)
  - p99가 급격히 상승(경고/원인 탐색)

### 5.3 DB 커넥션 풀 포화(원인)
- 조건 예시(개념):
  - active == max에 근접 + 요청 지연 증가 동반 시 강하게

### 5.4 JVM/프로세스(원인)
- 조건 예시(개념):
  - OOM/재시작 반복, GC pause 증가, 스레드 풀 대기 증가

### 5.5 디스크 사용량(원인, 그러나 매우 중요)
- 조건 예시(개념):
  - 디스크 80% 경고, 90% 페이지
- 특히 로컬/도커 환경은 로그/볼륨/TSDB로 폭증하므로 보관 상한(week10 compose의 retention)과 함께 운영합니다.

## 6) 알림이 울렸을 때의 “최소 대응” 템플릿
1. **증상 확인:** error/latency가 사용자 영향인지 확인
2. **영향 범위:** 어떤 기능/엔드포인트/사용자군인지
3. **최근 변경:** 배포/설정/데이터 마이그레이션
4. **완화:** 롤백/차단/부하 제한/스케일
5. **재발 방지:** 해당 알림의 기준 조정 + 런북 보강 + 테스트/대시보드 개선

## 7) 다음 단계(원하면 확장)
- 실제 Prometheus alert rules 파일을 추가하고, Grafana 패널에서 runbook 링크를 연결
- “에러 버짓 소모율” 기반 MWB 알림까지 구현

