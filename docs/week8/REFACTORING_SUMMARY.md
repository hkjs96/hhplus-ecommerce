# Week 8: 이벤트 기반 아키텍처 개선 과정 요약

이 문서는 8주차 과제 수행을 위해 프로젝트를 분석하고, 이벤트 기반 아키텍처를 도입하여 개선한 과정과 핵심 고려사항을 정리한 문서입니다.

---

## 1. 초기 분석 및 목표 설정

### 1.1 분석 시작점

8주차 학습 목표인 "트랜잭션 분리 및 이벤트 기반 관심사 분리"를 달성하기 위해, 먼저 프로젝트 내에서 가장 복잡하고 여러 도메인이 얽혀있는 **결제 프로세스**를 분석 대상으로 선정했습니다. 초기 가설은 다음과 같았습니다.

- "결제 로직(`ProcessPaymentUseCase`) 내에 외부 API 호출과 같은 부가 로직이 포함되어 있어 트랜잭션이 길어지고, 다른 도메인과의 결합도가 높을 것이다."

### 1.2 핵심 발견: 이미 분리된 트랜잭션과 숨겨진 확장 포인트

`codebase_investigator`와 실제 코드 분석을 통해 예상과 다른, 이미 상당히 고도화된 구조임을 발견했습니다.

1.  **견고한 Saga 패턴:** 결제 프로세스는 이미 Saga 패턴을 통해 '잔액/재고 차감'과 '외부 PG사 호출'이 분리되어 있었습니다. 이로 인해 DB Connection Pool 고갈 문제는 이미 해결된 상태였습니다.
2.  **숨겨진 확장 포인트:** 가장 중요한 발견은, 결제 성공 후 `PaymentTransactionService`에서 이미 **`PaymentCompletedEvent`를 발행**하고 있었다는 점입니다.

### 1.3 최종 목표 재설정

초기 가설과 달리, 기존의 견고한 트랜잭션을 부수는 것은 올바른 방향이 아니라고 판단했습니다. 대신, 이미 존재하는 `PaymentCompletedEvent`를 "확장 포인트"로 활용하여 **결제 성공 이후의 모든 부가 로직을 이벤트 기반으로 분리하는 것**으로 최종 목표를 재설정했습니다.

---

## 2. 개선 포인트 및 적용 과정

### Point 1: 부가 로직의 식별 및 분리

- **사고 과정 (Thought Process):**
  - 과제 요구사항에 명시된 "데이터 플랫폼에 주문 정보 전송"과 일반적인 커머스 기능인 "결제 완료 알림 발송"은 결제 성공의 핵심 조건이 아닙니다.
  - 만약 데이터 플랫폼이 장애 상태이거나 알림 API가 지연되더라도, 사용자의 결제는 반드시 성공해야 합니다.
  - 따라서 이들을 **부가 로직**으로 식별하고, 결제 프로세스의 주 흐름에서 분리하기로 결정했습니다.

- **적용 과정 (Application):**
  - **`DataPlatformEventListener.java` 생성:** 데이터 플랫폼 연동을 시뮬레이션하는 리스너를 생성했습니다.
  - **`PaymentNotificationListener.java` 생성:** 사용자 알림 발송을 시뮬레이션하는 리스너를 생성했습니다.
  - 두 리스너 모두 `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)`을 사용하여, 핵심 결제 트랜잭션이 **완전히 성공(커밋)한 후에만** 동작하도록 보장했습니다.

### Point 2: 비동기 처리를 통한 안정성 및 응답성 확보

- **사고 과정 (Thought Process):**
  - 분리된 부가 로직, 특히 외부 시스템과 통신하는 로직은 실패하거나 지연될 수 있습니다.
  - 만약 하나의 리스너에서 예외가 발생했을 때, 다른 리스너의 실행에 영향을 주어서는 안 됩니다. (e.g., 데이터 플랫폼 장애가 알림 발송까지 막는 상황 방지)
  - 또한, 외부 API 호출로 인한 시간 지연이 다음 이벤트 처리에 영향을 주지 않도록 격리해야 합니다.

- **적용 과정 (Application):**
  - **`@Async` 적용:** 각 리스너의 메서드에 `@Async`를 적용하여 별도의 스레드에서 비동기적으로 실행되도록 했습니다.
  - **`AsyncConfig.java` 생성:** `@EnableAsync`를 활성화하고, 전용 스레드 풀(`ThreadPoolTaskExecutor`)을 설정하여 무분별한 스레드 생성을 방지하고 시스템 리소스를 효율적으로 사용하도록 구성했습니다.
  - **결과:** 이를 통해 리스너 간의 실행이 완벽히 격리되었고, 하나의 리스너에서 발생한 예외나 지연이 다른 리스너에게 전파되지 않아 시스템 전체의 안정성이 크게 향상되었습니다.

### Point 3: 테스트를 통한 검증

- **사고 과정 (Thought Process):**
  - 이벤트 기반의 비동기 로직은 눈에 보이지 않는 스레드에서 동작하기 때문에, 동작 여부를 반드시 테스트로 검증해야 합니다.
  - 단순히 "호출되었다"를 넘어, "트랜잭션이 롤백되었을 때는 호출되지 않는지"까지 검증해야 정합성을 신뢰할 수 있습니다.

- **적용 과정 (Application):**
  - **`PaymentEventIntegrationTest.java` 생성:** 통합 테스트 환경에서 실제 유스케이스를 실행하는 테스트를 작성했습니다.
  - **`@MockBean` 활용:** 실제 외부 API를 호출하는 `DataPlatformEventListener`와 `PaymentNotificationListener`를 Mock으로 대체하여, 외부 의존성 없이 테스트를 수행했습니다.
  - **`Awaitility` 라이브러리 사용:** 비동기 로직이 완료될 때까지 최대 5초간 기다리면서, `verify()`를 통해 Mock Bean의 메서드가 정확히 호출되었는지 검증했습니다. 이를 통해 보이지 않는 비동기 흐름을 신뢰성 있게 테스트할 수 있었습니다.

---

## 3. 최종 설계 요약

- **Before (개선 전):** `ProcessPaymentUseCase`가 결제 성공 후, 랭킹 업데이트 로직을 처리하는 `RankingEventListener`와 암묵적으로 결합되어 있었습니다. 다른 부가 기능이 추가될 경우, `ProcessPaymentUseCase`나 주변 로직의 변경이 필요할 수 있는 구조였습니다.

- **After (개선 후):** `ProcessPaymentUseCase`는 오직 결제 트랜잭션의 성공과 `PaymentCompletedEvent` 발행이라는 핵심 책임만 가집니다. **'랭킹', '데이터 전송', '알림'** 등 모든 부가 기능은 이 이벤트를 구독하는 독립적인 리스너들에 의해 **완벽히 분리되어 비동기적으로 처리됩니다.**

이러한 이벤트 기반 아키텍처로의 개선을 통해, 시스템은 더욱 유연하고 확장 가능하며 안정적인 구조를 갖추게 되었습니다. 상세한 설계 내용은 `TRANSACTION_SEPARATION_DESIGN.md` 문서에서 확인할 수 있습니다.

---

## 부록: 주문 생성의 멱등성 구현 분석

초기 분석 단계에서는 '주문 생성'(`CreateOrderUseCase`) 기능에 '잔액 충전'(`ChargeBalanceUseCase`)과 같은 수준의 멱등성 및 동시성 제어 로직이 없을 것으로 가정하고, 이를 추가하는 것을 주요 개선 목표 중 하나로 고려했습니다.

하지만, `CreateOrderUseCase`의 코드를 직접 검토한 결과, **이미 매우 높은 수준의 보호 로직이 구현되어 있음을 확인했습니다.** 이는 예상치 못한 긍정적인 발견이었습니다.

### `CreateOrderUseCase`의 기존 멱등성/동시성 제어 전략

1.  **`@DistributedLock` 적용**: `execute` 메서드에 멱등성 키(`idempotencyKey`)를 기반으로 한 분산 락이 적용되어 있습니다. 이를 통해 동일한 요청이 여러 스레드에서 동시에 처리되는 것을 원천적으로 차단합니다.
2.  **멱등성 테이블(`OrderIdempotency`) 활용**:
    *   요청이 시작될 때 멱등성 키로 `OrderIdempotency` 테이블을 조회합니다.
    *   **처리 중(PROCESSING)** 상태의 요청이 있으면, 중복 요청으로 간주하고 즉시 409 Conflict 에러를 반환합니다.
    *   **완료(COMPLETED)** 상태의 요청이 있으면, 다시 처리하지 않고 저장된 이전 응답(`responsePayload`)을 즉시 반환합니다.
3.  **별도 트랜잭션을 통한 상태 저장**: `IdempotencySaveService`라는 별도의 서비스를 통해 `Propagation.REQUIRES_NEW` 옵션으로 멱등성 상태(PROCESSING, COMPLETED, FAILED)를 저장합니다. 이는 주 비즈니스 로직의 트랜잭션과 분리되어, 멱등성 상태가 롤백되는 것을 방지하는 매우 견고한 설계입니다.

### 결론: 방향 전환

`CreateOrderUseCase`가 이미 모범적인 수준의 멱등성 및 동시성 제어 로직을 갖추고 있었기 때문에, **초기 계획이었던 '멱등성 리팩토링'은 불필요하다고 판단했습니다.**

대신, 분석 과정에서 발견한 또 다른 확장 포인트인 **`PaymentCompletedEvent`**를 활용하여, 결제 이후의 부가 로직들을 분리하는 방향으로 개선 작업을 전환했습니다. 이는 현재 코드베이스의 강점은 유지하면서, 8주차 학습 목표인 '관심사 분리'를 달성하는 가장 효과적인 방법이었습니다.
